(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{548:function(t,n,e){"use strict";e.r(n);var s=e(6),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"今日内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#今日内容"}},[t._v("#")]),t._v(" 今日内容")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1. Junit单元测试\n2. 反射\n3. 注解\n")])])]),e("h2",{attrs:{id:"junit单元测试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#junit单元测试"}},[t._v("#")]),t._v(" Junit单元测试：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("* 测试分类：\n\t1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。\n\t2. 白盒测试：需要写代码的。关注程序具体的执行流程。\n\n* Junit使用：白盒测试\n\t* 步骤：\n\t\t1. 定义一个测试类(测试用例)\n\t\t\t* 建议：\n\t\t\t\t* 测试类名：被测试的类名Test\t\tCalculatorTest\n\t\t\t\t* 包名：xxx.xxx.xx.test\t\tcn.itcast.test\n\n\t\t2. 定义测试方法：可以独立运行\n\t\t\t* 建议：\n\t\t\t\t* 方法名：test测试的方法名\t\ttestAdd()  \n\t\t\t\t* 返回值：void\n\t\t\t\t* 参数列表：空参\n\n\t\t3. 给方法加@Test\n\t\t4. 导入junit依赖环境\n\n\t* 判定结果：\n\t\t* 红色：失败\n\t\t* 绿色：成功\n\t\t* 一般我们会使用断言操作来处理结果\n\t\t\t* Assert.assertEquals(期望的结果,运算的结果);\n\n\t* 补充：\n\t\t* @Before:\n\t\t\t* 修饰的方法会在测试方法之前被自动执行\n\t\t* @After:\n\t\t\t* 修饰的方法会在测试方法执行之后自动被执行\n")])])]),e("h2",{attrs:{id:"反射-框架设计的灵魂"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反射-框架设计的灵魂"}},[t._v("#")]),t._v(" 反射：框架设计的灵魂")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码\n* 反射：将类的各个组成部分封装为其他对象，这就是反射机制\n\t* 好处：\n\t\t1. 可以在程序运行过程中，操作这些对象。\n\t\t2. 可以解耦，提高程序的可扩展性。\n\n\n* 获取Class对象的方式：\n\t1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象\n\t\t* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n\t2. 类名.class：通过类名的属性class获取\n\t\t* 多用于参数的传递\n\t3. 对象.getClass()：getClass()方法在Object类中定义着。\n\t\t* 多用于对象的获取字节码的方式\n\n\t* 结论：\n\t\t同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。\n\n\n* Class对象功能：\n\t* 获取功能：\n\t\t1. 获取成员变量们\n\t\t\t* Field[] getFields() ：获取所有public修饰的成员变量\n\t\t\t* Field getField(String name)   获取指定名称的 public修饰的成员变量\n\n\t\t\t* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符\n\t\t\t* Field getDeclaredField(String name)  \n\t\t2. 获取构造方法们\n\t\t\t* Constructor<?>[] getConstructors()  \n\t\t\t* Constructor<T> getConstructor(类<?>... parameterTypes)  \n\n\t\t\t* Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)  \n\t\t\t* Constructor<?>[] getDeclaredConstructors()  \n\t\t3. 获取成员方法们：\n\t\t\t* Method[] getMethods()  \n\t\t\t* Method getMethod(String name, 类<?>... parameterTypes)  \n\n\t\t\t* Method[] getDeclaredMethods()  \n\t\t\t* Method getDeclaredMethod(String name, 类<?>... parameterTypes)  \n\n\t\t4. 获取全类名\t\n\t\t\t* String getName()  \n\n\n* Field：成员变量\n\t* 操作：\n\t\t1. 设置值\n\t\t\t* void set(Object obj, Object value)  \n\t\t2. 获取值\n\t\t\t* get(Object obj) \n\n\t\t3. 忽略访问权限修饰符的安全检查\n\t\t\t* setAccessible(true):暴力反射\n\n\n\n* Constructor:构造方法\n\t* 创建对象：\n\t\t* T newInstance(Object... initargs)  \n\n\t\t* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法\n\n\n* Method：方法对象\n\t* 执行方法：\n\t\t* Object invoke(Object obj, Object... args)  \n\n\t* 获取方法名称：\n\t\t* String getName:获取方法名\n\n\n* 案例：\n\t* 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法\n\t\t* 实现：\n\t\t\t1. 配置文件\n\t\t\t2. 反射\n\t\t* 步骤：\n\t\t\t1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中\n\t\t\t2. 在程序中加载读取配置文件\n\t\t\t3. 使用反射技术来加载类文件进内存\n\t\t\t4. 创建对象\n\t\t\t5. 执行方法\n')])])]),e("h2",{attrs:{id:"注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注解"}},[t._v("#")]),t._v(" 注解：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('* 概念：说明程序的。给计算机看的\n* 注释：用文字描述程序的。给程序员看的\n\n* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n* 概念描述：\n\t* JDK1.5之后的新特性\n\t* 说明程序的\n\t* 使用注解：@注解名称\n\t\n\n* 作用分类：\n\t①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】\n\t②代码分析：通过代码里标识的注解对代码进行分析【使用反射】\n\t③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n\n* JDK中预定义的一些注解\n\t* @Override\t：检测被该注解标注的方法是否是继承自父类(接口)的\n\t* @Deprecated：该注解标注的内容，表示已过时\n\t* @SuppressWarnings：压制警告\n\t\t* 一般传递参数all  @SuppressWarnings("all")\n\n* 自定义注解\n\t* 格式：\n\t\t元注解\n\t\tpublic @interface 注解名称{\n\t\t\t属性列表;\n\t\t}\n\n\t* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口\n\t\t* public interface MyAnno extends java.lang.annotation.Annotation {}\n\n\t* 属性：接口中的抽象方法\n\t\t* 要求：\n\t\t\t1. 属性的返回值类型有下列取值\n\t\t\t\t* 基本数据类型\n\t\t\t\t* String\n\t\t\t\t* 枚举\n\t\t\t\t* 注解\n\t\t\t\t* 以上类型的数组\n\n\t\t\t2. 定义了属性，在使用时需要给属性赋值\n\t\t\t\t1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。\n\t\t\t\t2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。\n\t\t\t\t3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略\n\t\n\t* 元注解：用于描述注解的注解\n\t\t* @Target：描述注解能够作用的位置\n\t\t\t* ElementType取值：\n\t\t\t\t* TYPE：可以作用于类上\n\t\t\t\t* METHOD：可以作用于方法上\n\t\t\t\t* FIELD：可以作用于成员变量上\n\t\t* @Retention：描述注解被保留的阶段\n\t\t\t* @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到\n\t\t* @Documented：描述注解是否被抽取到api文档中\n\t\t* @Inherited：描述注解是否被子类继承\n\n\n* 在程序使用(解析)注解：获取注解中定义的属性值\n\t1. 获取注解定义的位置的对象  （Class，Method,Field）\n\t2. 获取指定的注解\n\t\t* getAnnotation(Class)\n\t\t//其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\t            public class ProImpl implements Pro{\n\t                public String className(){\n\t                    return "cn.itcast.annotation.Demo1";\n\t                }\n\t                public String methodName(){\n\t                    return "show";\n\t                }\n\t            }\n\t3. 调用注解中的抽象方法获取配置的属性值\n\n\n* 案例：简单的测试框架\n* 小结：\n\t1. 以后大多数时候，我们会使用注解，而不是自定义注解\n\t2. 注解给谁用？\n\t\t1. 编译器\n\t\t2. 给解析程序用\n\t3. 注解不是程序的一部分，可以理解为注解就是一个标签')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);